\documentclass{memarticle}
\usepackage{marvosym} % to define \MVAt
\newcommand{\docnumber}%
  {draft 1}

\newcommand{\doctitle}%
  {DRAFT---{\color{magenta}Specification of the Fermilab Hierarchical Configuration Language}---DRAFT}

\newcommand{\shorttitle}%
 {DRAFT---Specification of the FHiCL---DRAFT}

\newcommand{\authors}%
  {
  Jim~Kowalkowski \\
  Marc~Paterno
  }

\hypersetup%
  { pdfauthor={}%
  , pdftitle={\doctitle}%
  , pdfkeywords={}%
  , pdfsubject={}%
  }

\tightlists

\makeindex

\begin{document}
\topmatter
\chapter{Introduction}

\section{Purpose of this document}
This document provides the formal specification
for the \emph{Fermilab Hierarchical Configuration Language}, FHiCL.
The specification include several aspects of FHiCL:
user requirements, definitions of structural elements,
canonical value representations,
and a grammar thatdescribes the syntax of a conformant FHiCL document.

\section{Rationale}

\begin{fixme}
  Why does this project exist?
\end{fixme}

\section{Scope of this facility}

\begin{fixme}
  What does this include? What does it not include?
\end{fixme}

\section{Definitions}

\section{Known problems with document}

The preprocessor definition section is missing.  We now allow whitespace at the end of the include line.
The syntax of the references has changes.  Now it is '@local::'.

\chapter{User Requirements}

Representatives from LQCD, mu2e, NOvA, and JDEM contributed to the requirements 
of this language.

\begin{itemize}
\item allowable special characters within string values are newline, tab
\item values that are \emph{simple words} and without whitespace do not need to be quoted
\item single quoted values are read verbatim (no escape processing)
\item value that are double quoted can contained escaped special characters, double quotes and backslashes
\item two tables are the same when their hash code is the same (the byte sequences fed into the hash must be identical)
\item the canonical representation of an atom is a sequence of printable characters
\item values of true and ``true'' are identical
\item every atom can be requested in canonical string form
\item to include leading or trailing zeros in a any number, the number must be quoted
\item the small range of a real or integer value is 1,000,000
\item real number with no fraction will be converted to integer format if within the small range
\item a canonical real has no leading zeros in exponent or fraction, lower case e, with plus or minus
\item canonical integers have no leading zeros
\item null is not supported
\item infinity, +infinity becomes ``infinity'', 
\item ``infinity'' stays ``infinity''
\item -infinity is support
\item adding a double to a parameter set programmatically will have a rule that specified how it will be done
\item 00.000E+000 will be ``0.0'' in canonical form
\item any exponent as e+0 will be stripped in the canonical form
\item -0.0 retains the negative
\item nil and ``nil'' are the same thing
\item string concatenation operations are permitted, but only quoted string values
\item no unquoted white space is permitted
\item quotes for string values can be left out if the string value has no white space and is ``simple''
\end{itemize}

Preprocessing and \#pragma definitions need to be covered.

\chapter{FHiCL syntax}

The FHiCL syntax is defined by the following bison grammar:
\begin{verbatim}
\import{"bnf.y"}
\end{verbatim}

In this grammar,
all uppercase names denote tokens.
These tokens are defined by the following flex specification:
\begin{verbatim}
\include{"bnf.l"}
\end{verbatim}

\begin{fixme}
  Note: we do not provide a way to represent all possible sequences of
  bytes, nor even a way to represent all possbile sequences of ASCII
  characters. Only printable characters, and the control characters
  \texttt{tab} and \texttt{newline}, are representable.
\end{fixme}

\section{High-level entities}

For all the rules in this section,
whitespace is allowed between any two tokens,
and is not significant.

The \emph{document} is the highest-level construct
in FHiCL.
Any implementation of an FHiCL parser
processes a \emph{document}
as if were a single string.

A \emph{document} consists of a mixture of
zero or more \emph{definitions}
and \emph{overrides},
and exactly one \emph{table},
which are all comma-separated:

An element of type \emph{definition} is used to
create a new element:

An element of type \emph{override} is used to
change the value of an existing element,
or to create a new element in a \emph{table} or \emph{sequence}.

An element of type \emph{value} is either a \emph{table},
a \emph{sequence},
or an \emph{atom}:
The definitions of \emph{table}, \emph{sequence} and \emph{atom} are mutually interdependent.

Elements of type \emph{table} are denoted by (possibly empty) braces;
the elements within the braces
are \emph{definitions}
which are separated by commas:

Elements of type \emph{sequence} are denoted by (possibly empty) brackets;
the elements within the brackets can be any value,
and are separated by commas:

\section{Mid-level entities}

For all rules in this section,
whitespace is allowed only where specified by the whitespace token \emph{ws}.

A \emph{name} is used to begin a \emph{definition}:

\break
A hierarchical name,
or \emph{hname},
is used in begin an \emph{override}:

The most basic unit of the configuration language is the \emph{atom}:

Note that a leading $+$ is not legal,
nor is a leading 0 legal unless it is the sole character.

\section{Recognized atoms}

An \emph{atom} is: 
\begin{verbatim}
atom: number | string | NIL | BOOLVALUE | REF
\end{verbatim}


For all rules in this section,
whitespace is not allowed between tokens.

A \emph{char} is one of:
\begin{enumerate}
\item any ASCII character except for
the double-quote ('') 
or the reverse solidus (\textbackslash)
or control characters
(\emph{printable} characters), or
\item an escaped double-quote or reverse solidus or solidus
(escaping is done with a reverse solidus), or
\item one of a number escape sequences, noted below.
\end{enumerate}

An \emph{alpha} is any of the ASCII characters \texttt{a}--\texttt{z}
or \texttt{A}--\texttt{Z}.

A \emph{digit} is any of the ASCII characters \texttt{0}--\texttt{9}.
We distinguish between zero digits and nonzero digits:

A \emph{ws} is one of the three whitespace characters:

\chapter{FHiCL semantics}
\section{High-level result of a successful parse}

The result of parsing a \emph{document}
is a single \emph{table}.
The \emph{definition}s and \emph{override}s
appearing before the top-level \emph{table}
are intended to allow the user
to supply values to be substituted into element in the \emph{table}.
The \emph{definition}s and \emph{override}s
appearing after the top-level \emph{table}
are intended to allow the user
to replace values in that table.

\section{Representation of atoms\index{atoms}}
In the parse results,
all \emph{atom}s
except for \texttt{null} and \emph{ref}
are represented
as character strings.
The atom \texttt{null} is represented by a 
value specified by the binding for a given programming language.
The resolution of \emph{ref}s is described in section~\ref{sec:refs} below.

Each language binding
provides its own mechanism
for turning atoms of type \emph{integer}, \emph{real} and \emph{complex}
from their string representation
into the appropriate numerical representation.

\section{Resolution of \emph{ref}s\label{sec:refs}}
Atoms of type \emph{ref} are replaced
by the value indicated by the \emph{hname} part of the \emph{ref},
where the environment in which the \emph{hname} is evaluated is determined
by the \texttt{db} or \texttt{local} at the end of the \emph{ref}.

The presence of \texttt{local} indicates 
that the scope in which the \emph{hname} is to be sought
is the previously-read \emph{document} text.
The presence of \texttt{db} indicates
that the scope in which the \emph{hname} is evaluated
is the single database
to which the parser has access.
If the parser has no access to a database,
and a \emph{ref} which ends in \texttt{db} is encountered,
a parse failure results.
If,
in the appropriate scope,
the \emph{hname} in a \emph{ref} does not resolve to any \emph{value},
a parse failure results.

\chapter{Preprocssor}

\chapter{Features of programming language binding}

\section{General requirements}


\section{Additional requirements for dynamically typed languages}

Tables and sequences should be represented by a built-in type of the
programming language.

If the target programming language has a standard JSON library, we
want to make sure that our constructs can be translated to JSON format
and back without use of any FHiCL-specific library.

It is important that code that uses the representation of a
\emph{table} not need any FHiCL-specific code.

\chapter{Output requirements}

\section{Output intended for human reading}
\begin{fixme}
  Pretty-printing description here.
\end{fixme}
\section{Output intended for machine reading}
\begin{fixme}
  ASCII dump facility, machine reparsable, and the same on all
  platforms. Very terse.
\end{fixme}

%\appendix

\printindex

\end{document}
